<p>﻿</p>
<h1 id="javascript-json">JavaScript 与 JSON</h1>
<p>本笔记是在学习 MongoDB 的记录笔记，持续补充中，在学习的过程中参考了下面的教程。想要继续学习的朋友可以根据链接找到更多的内容：</p>
<p><a href="http://www.runoob.com/mongodb/mongodb-tutorial.html">MongoDB 教程 | 菜鸟教程</a>
<a href="http://www.imooc.com/learn/295">mongoDB入门篇</a>
<a href="https://book.douban.com/subject/25798102/">MongoDB权威指南</a></p>
<!--more-->
<h2 id="rdbms-nosql">RDBMS 和 NoSQL</h2>
<h3 id="-acid-">关系型数据库遵循ACID规则</h3>
<h4 id="a-atomicity-">A (Atomicity) 原子性</h4>
<p>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。</p>
<p>比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</p>
<h4 id="c-consistency-">C (Consistency) 一致性</h4>
<p>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。</p>
<p>例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。</p>
<h4 id="i-isolation-">I (Isolation) 独立性</h4>
<p>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。</p>
<p>比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。</p>
<h4 id="d-durability-">D (Durability) 持久性</h4>
<p>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</p>
<h3 id="nosql">NoSQL</h3>
<p>NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。</p>
<p><strong>NoSQL用于超大规模数据的存储</strong>。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以<strong>横向扩展</strong>。</p>
<h3 id="rdbms-vs-nosql">RDBMS vs NoSQL</h3>
<p>RDBMS </p>
<ol>
<li>高度组织化结构化数据 </li>
<li>结构化查询语言（SQL） (SQL) </li>
<li>数据和关系都存储在单独的表中。 </li>
<li>数据操纵语言，数据定义语言 </li>
<li>严格的一致性</li>
<li>基础事务</li>
</ol>
<p>NoSQL </p>
<ol>
<li>代表着不仅仅是SQL</li>
<li>没有声明性查询语言</li>
<li>没有预定义的模式</li>
<li>键 - 值对存储，列存储，文档存储，图形数据库</li>
<li>最终一致性，而非ACID属性</li>
<li>非结构化和不可预知的数据</li>
<li>CAP定理 </li>
<li>高性能，高可用性和可伸缩性</li>
</ol>
<p><img src="http://www.runoob.com/wp-content/uploads/2013/10/bigdata.png" alt=""></p>
<p>由上图可以知道，网络中出现的非结构化的数据越来越多，不同种类的数据类型也越来越多，所以使用 NoSQL 可以更好地处理这些非结构化的数据。</p>
<h3 id="cap-cap-theorem-">CAP定理（CAP theorem）</h3>
<p>在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer&#39;s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:</p>
<ol>
<li>一致性(Consistency) (所有节点在同一时间具有相同的数据)</li>
<li>可用性(Availability) (保证每个请求不管成功或者失败都有响应)</li>
<li>分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)</li>
</ol>
<p>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：</p>
<ol>
<li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li>
<li>CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。</li>
<li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li>
</ol>
<p>BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:</p>
<ol>
<li>Basically Availble --基本可用</li>
<li>Soft-state --软状态/柔性事务。</li>
<li>Eventual Consistency --最终一致性 最终一致性， 也是是 ACID 的最终目的。</li>
</ol>
<h3 id="nosql-">NoSQL 数据库分类</h3>
<pre><code>列存储    :
Hbase
Cassandra
Hypertable
顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。

文档存储 :
MongoDB
CouchDB
文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有有机会对某些字段建立索引，实现关系数据库的某些功能。

key-value存储 :
Tokyo Cabinet / Tyrant
Berkeley DB
MemcacheDB
Redis
可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能）

图存储 :
Neo4J
FlockDB
图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。

对象存储 :
db4o
Versant
通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。

xml数据库 :
Berkeley DB XML
BaseX
高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。
</code></pre><h2 id="mongodb-">MongoDB 概念解析</h2>
<pre><code>SQL术语/概念    MongoDB术语/概念    解释/说明
database          database          数据库
table             collection        数据库表/集合
row                  document       数据记录行/文档
column               field        数据字段/域
index               index          索引
table              joins    表连接,MongoDB不支持
primary key        primary key    主键,MongoDB自动将_id字段设置为主键
</code></pre><p>MongoDB 中的数据类型</p>
<p>MongoDB区分类型和大小写。</p>
<pre><code>数据类型                          描述
String          字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。
Integer          整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。
Boolean          布尔值。用于存储布尔值（真/假）。
Double          双精度浮点值。用于存储浮点值。
Min/Max keys  将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。
Arrays          用于将数组或列表或多个值存储为一个键。
Timestamp      时间戳。记录文档修改或添加的具体时间。
Object          用于内嵌文档。
Null          用于创建空值。
Symbol          符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。
Date          日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。
Object ID      对象 ID。用于创建文档的 ID。
Binary Data      二进制数据。用于存储二进制数据。
Code          代码类型。用于在文档中存储 JavaScript 代码。
Regular expression    正则表达式类型。用于存储正则表达式。
</code></pre><p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p>
<ol>
<li>admin： 从权限的角度来看，这是&quot;root&quot;数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>
<li>local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li>
</ol>
<h2 id="-">数据库</h2>
<p><strong>创建数据库</strong></p>
<pre><code>use DATABASE_NAME
</code></pre><p>如果数据库不存在，则创建数据库，否则切换到指定数据库。</p>
<p><strong>查看当前数据库</strong></p>
<pre><code>&gt; db
  zyc
</code></pre><p><strong>查看所有数据库</strong></p>
<p>如果你想查看所有数据库，可以使用 show dbs 命令：</p>
<pre><code>show dbs
</code></pre><p>可以看到，我们刚创建的数据库 zyc 并不在数据库的列表中， 要显示它，我们需要向 zyc 数据库插入一些数据。</p>
<pre><code>&gt; show dbs
  admin  0.000GB
  local  0.000GB
&gt; db
  zyc
&gt; db.zyc.insert({&#39;id&#39;: &#39;BUPT&#39;})
  WriteResult({ &quot;nInserted&quot; : 1 })
&gt; show dbs
  admin  0.000GB
  local  0.000GB
  zyc    0.000GB
</code></pre><p>MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。</p>
<p><strong>删除数据库</strong></p>
<p>MongoDB 删除数据库的语法格式如下：</p>
<pre><code>db.dropDatabase()
</code></pre><p>删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名。</p>
<pre><code>&gt; db.dropDatabase()
  { &quot;dropped&quot; : &quot;zyc&quot;, &quot;ok&quot; : 1 }
</code></pre><h2 id="-">集合</h2>
<p>集合的概念就和 RDBMS 中的 table 是一个概念</p>
<p><strong>给集合插入数据</strong></p>
<p>使用 [collection].insert() 来插入数据，如果该集合不存在，则会创建。</p>
<pre><code>&gt; db.mongo.insert({&#39;id&#39;: &#39;first mongodb collection&#39;})
  WriteResult({ &quot;nInserted&quot; : 1 })
&gt; show tables;
  mongo
</code></pre><p><strong>查看所有的集合</strong></p>
<pre><code>&gt; show tables;
  mongo
</code></pre><p><strong>删除集合</strong></p>
<pre><code>&gt; db.mongo.drop()
  true
&gt; show tables;
</code></pre><h2 id="-">文档</h2>
<p>文档的数据结构和JSON基本一样。
所有存储在集合中的数据都是BSON格式。
BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。</p>
<h3 id="-">插入文档</h3>
<p>MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下：</p>
<pre><code>db.COLLECTION_NAME.insert(document)
</code></pre><p>插入文档的数据，必须要是一个 <code>document</code>，也就是一个有 key-value 对的 <code>{}</code>。如果 key-value 对中没有 &#39;_id&#39; 存在，则会默认生成一个 <code>ObjectId</code> 类型的键值对，用来表示这个文档。</p>
<p>比如：</p>
<pre><code>&gt; db.mongo.insert({&#39;id&#39;: &#39;first mongodb collection&#39;})
  WriteResult({ &quot;nInserted&quot; : 1 })
&gt; db.mongo.find()
  { &quot;_id&quot; : ObjectId(&quot;58d22b9f123c0b38c9226ad7&quot;), &quot;id&quot; : &quot;first mongodb collection&quot; }
</code></pre><p>insert 和 save 的区别：</p>
<p>通过在 mongodb 中执行 <code>db.COLLECTION_NAME.insert</code> 和 <code>db.COLLECTION_NAME.save</code>，可以通过返回值得到这个函数的逻辑。</p>
<pre><code>&gt; db.mongo.save
function (obj, opts) {
    if (obj == null)
        throw Error(&quot;can&#39;t save a null&quot;);

    if (typeof(obj) == &quot;number&quot; || typeof(obj) == &quot;string&quot;)
        throw Error(&quot;can&#39;t save a number or string&quot;);

    if (typeof(obj._id) == &quot;undefined&quot;) {
        obj._id = new ObjectId();
        return this.insert(obj, opts);
    } else {
        return this.update({_id: obj._id}, obj, Object.merge({upsert: true}, opts));
    }
}
</code></pre><p>我们可以看到，<code>save</code> 无法保存 null、number、string，当然 insert 也无法保存这几种数据类型。</p>
<p>通过 <code>save</code> 的逻辑中可以看出，如果这个 <code>obj</code> 没有在集合中存过，则调用 <code>insert</code> 方法将这个文档存入。如果在集合中已经存在了这个文档，则进行 <code>update</code> 更新文档。</p>
<p>我们也可以将数据定义为一个变量，如下所示：</p>
<pre><code>&gt; document=({title: &#39;MongoDB 教程&#39;, 
    description: &#39;MongoDB 是一个 Nosql 数据库&#39;,
    by: &#39;菜鸟教程&#39;,
    url: &#39;http://www.runoob.com&#39;,
    tags: [&#39;mongodb&#39;, &#39;database&#39;, &#39;NoSQL&#39;],
    likes: 100
});
</code></pre><p>执行插入操作：</p>
<pre><code>&gt; db.col.insert(document)
  WriteResult({ &quot;nInserted&quot; : 1 })
</code></pre><h3 id="-">查找集合中所有的文档</h3>
<pre><code>db.COLLECTION_NAME.find()
</code></pre><p>将返回集合中所有的元素。</p>
<p>也可以在 <code>find()</code> 的返回值中调用 <code>pretty()</code> 方法，将优化 Shell 输出样式：</p>
<pre><code>&gt; db.mongo.find().pretty()
{
    &quot;_id&quot; : ObjectId(&quot;58d22b9f123c0b38c9226ad7&quot;),
    &quot;id&quot; : &quot;first mongodb collection&quot;
}
</code></pre><p>可以通过<strong>条件操作符</strong>来选择查询的条件</p>
<p>MongoDB中条件操作符有：</p>
<ol>
<li>(&gt;) 大于 - <code>$gt</code></li>
<li>(&lt;) 小于 - <code>$lt</code></li>
<li>(&gt;=) 大于等于 - <code>$gte</code></li>
<li>(&lt;= ) 小于等于 - <code>$lte</code></li>
</ol>
<p><img src="http://ojt6zsxg2.bkt.clouddn.com/a6683c803916e1270d6de367203b4cfb.png" alt=""></p>
<p><strong>MongoDB AND 条件</strong></p>
<p>MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，及常规 SQL 的 AND 条件。
语法格式如下：</p>
<pre><code>&gt;db.col.find({key1:value1, key2:value2}).pretty()
</code></pre><p><strong>MongoDB OR 条件</strong></p>
<p>MongoDB OR 条件语句使用了关键字 <code>$or</code>,语法格式如下：</p>
<pre><code>&gt;db.col.find(
   {
      $or: [
         {key1: value1}, {key2:value2}
      ]
   }
).pretty()
</code></pre><p>以下实例演示了 AND 和 OR 联合使用，类似常规 SQL 语句为： <code>where likes&gt;50 AND (by = &#39;菜鸟教程&#39; OR title = &#39;MongoDB 教程&#39;)</code></p>
<pre><code>db.col.find({&quot;likes&quot;: {$gt:50}, $or: [{&quot;by&quot;: &quot;菜鸟教程&quot;},{&quot;title&quot;: &quot;MongoDB 教程&quot;}]}).pretty()
</code></pre><p><code>$type</code>操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果。</p>
<p>如果想获取 &quot;col&quot; 集合中 title 为 String 的数据，你可以使用以下命令：</p>
<pre><code>db.col.find({&quot;title&quot; : {$type : 2}})
</code></pre><p>其中 2 对应着 String 类型。所有的类型对应表如下：</p>
<p><img src="http://ojt6zsxg2.bkt.clouddn.com/15dfa8ac27f02a4b5efda5e4c39cfe34.png" alt="">
<img src="http://ojt6zsxg2.bkt.clouddn.com/a2e8a8faf1a641b9f7a68d1155063f77.png" alt=""></p>
<h4 id="-">读取指定数量的数据记录</h4>
<p>如果你需要在MongoDB中读取指定数量的数据记录，可以使用MongoDB的Limit方法，<code>limit()</code>方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。</p>
<pre><code>&gt;db.COLLECTION_NAME.find().limit(NUMBER)
</code></pre><p>我们除了可以使用<code>limit()</code>方法来读取指定数量的数据外，还可以使用<code>skip()</code>方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。</p>
<p><code>skip()</code>方法脚本语法格式如下：</p>
<pre><code>&gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)
</code></pre><h4 id="-">查找结果排序</h4>
<p>在MongoDB中使用<code>sort()</code>方法对数据进行排序，<code>sort()</code>方法可以通过参数指定排序的字段，并使用 <code>1</code> 和 <code>-1</code> 来指定排序的方式，其中 <code>1</code> 为升序排列，而<code>-1</code>是用于降序排列。</p>
<pre><code>&gt;db.COLLECTION_NAME.find().sort({KEY:1})
</code></pre><h3 id="-">删除集合中的文档</h3>
<pre><code>db.collection.remove(
   &lt;query&gt;,
   {
     justOne: &lt;boolean&gt;,
     writeConcern: &lt;document&gt;
   }
)
</code></pre><p>参数说明：</p>
<ul>
<li><code>query</code> :（可选）删除的文档的条件。</li>
<li><code>justOne</code> : （可选）如果设为 true 或 1，则只删除一个文档。</li>
<li><code>writeConcern</code> :（可选）抛出异常的级别。</li>
</ul>
<pre><code>db.col.remove({&#39;title&#39;:&#39;MongoDB 教程&#39;})
</code></pre><h3 id="-">更新集合中的文档</h3>
<p><code>update()</code> 方法用于更新已存在的文档。语法格式如下：</p>
<pre><code>db.collection.update(
   &lt;query&gt;,
   &lt;update&gt;,
   {
     upsert: &lt;boolean&gt;,
     multi: &lt;boolean&gt;,
     writeConcern: &lt;document&gt;
   }
)
</code></pre><p>参数说明：</p>
<ul>
<li><code>query</code> : update的查询条件，类似sql update查询内<code>where</code>后面的。</li>
<li><code>update</code> : update的对象和一些更新的操作符（如<code>$,$inc...</code>）等，也可以理解为sql update查询内<code>set</code>后面的</li>
<li><code>upsert</code> : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew，<code>true</code>为插入，默认是<code>false</code>，不插入。</li>
<li><code>multi</code> : 可选，mongodb 默认是<code>false</code>，只更新找到的第一条记录，如果这个参数为<code>true</code>，就把按条件查出来多条记录全部更新。</li>
<li><code>writeConcern</code> :可选，抛出异常的级别。</li>
</ul>
<h3 id="mongodb-">MongoDB 原子操作</h3>
<p>mongodb不支持事务，所以，在你的项目中应用时，要注意这点。无论什么设计，都不要要求mongodb保证数据的完整性。</p>
<p>但是mongodb提供了许多原子操作，比如文档的保存，修改，删除等，都是原子操作。</p>
<p>所谓原子操作就是要么这个文档保存到Mongodb，要么没有保存到Mongodb，不会出现查询到的文档没有保存完整的情况。</p>
<h4 id="-set">$set</h4>
<p>用来指定一个键并更新键值，若键不存在并创建。</p>
<pre><code>{ $set : { field : value } }
</code></pre><h4 id="-unset">$unset</h4>
<p>用来删除一个键。</p>
<pre><code>{ $unset : { field : 1} }
</code></pre><h4 id="-inc">$inc</h4>
<p>$inc可以对文档的某个值为数字型（只能为满足要求的数字）的键进行增减的操作。</p>
<pre><code>{ $inc : { field : value } }
</code></pre><h4 id="-push">$push</h4>
<p>把value追加到field里面去，field一定要是<strong>数组类型</strong>才行，如果field不存在，会<strong>新增一个数组类型</strong>加进去。</p>
<pre><code>{ $push : { field : value } }
</code></pre><h4 id="-pushall">$pushAll</h4>
<p>同$push,只是一次可以追加多个值到一个数组字段内。</p>
<pre><code>{ $pushAll : { field : value_array } }
</code></pre><h4 id="-pull">$pull</h4>
<p>从数组field内删除一个等于value值。</p>
<pre><code>{ $pull : { field : _value } }
</code></pre><h4 id="-addtoset">$addToSet</h4>
<p>增加一个值到数组内，而且只有当这个值不在数组内才增加。</p>
<h4 id="-pop">$pop</h4>
<p>删除数组的第一个或最后一个元素</p>
<pre><code>{ $pop : { field : 1 } }
</code></pre><h4 id="-rename">$rename</h4>
<p>修改字段名称</p>
<pre><code>{ $rename : { old_field_name : new_field_name } }
</code></pre><h4 id="-bit">$bit</h4>
<p>位操作，integer类型</p>
<pre><code>{$bit : { field : {and : 5}}}
</code></pre><h3 id="-">索引</h3>
<p>索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。
这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p>
<p>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构</p>
<p>MongoDB使用 ensureIndex() 方法来创建索引。</p>
<p>ensureIndex()方法基本语法格式如下所示：</p>
<pre><code>&gt;db.COLLECTION_NAME.ensureIndex({KEY:1})
</code></pre><p>语法中 Key 值为你要创建的索引字段，1为指定按升序创建索引，如果你想按降序来创建索引指定为-1即可。</p>
<p><img src="http://ojt6zsxg2.bkt.clouddn.com/d3dc9ecbb3587aeeb71b66fa8ba3bcd2.png" alt=""></p>
<h4 id="-">额外开销</h4>
<p>每个索引占据一定的存储空间，在进行插入，更新和删除操作时也需要对索引进行操作。所以，如果你很少对集合进行读取操作，建议不使用索引。</p>
<h4 id="-ram-">内存(RAM)使用</h4>
<p>由于索引是存储在内存(RAM)中,你应该确保该索引的大小不超过内存的限制。
如果索引的大小大于内存的限制，MongoDB会删除一些索引，这将导致性能下降。</p>
<h3 id="-">聚合</h3>
<p>MongoDB中聚合(aggregate)主要用于处理数据(诸如<strong>统计平均值,求和</strong>等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。</p>
<p>aggregate() 方法的基本语法格式如下所示：</p>
<pre><code>&gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)
</code></pre><p>举例</p>
<pre><code>&gt; db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$sum : 1}}}])
</code></pre><p>以上实例类似sql语句： select by_user, count(*) from mycol group by by_user</p>
<p>在上面的例子中，我们通过字段by_user字段对数据进行分组，并计算by_user字段相同值的总和。</p>
<p>下表展示了一些聚合的表达式:</p>
<p><img src="http://ojt6zsxg2.bkt.clouddn.com/99f7868e143b47f881a7f739dd4d3439.png" alt=""></p>
<h3 id="-">管道</h3>
<p>管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。</p>
<p>MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。</p>
<p><img src="http://ojt6zsxg2.bkt.clouddn.com/1afea3cbecb79b7bc1ded80547f119b2.png" alt=""></p>
<h2 id="mongodb-">MongoDB 数据库引用</h2>
<p>DBRef的形式：</p>
<pre><code>{ $ref : , $id : , $db :  }
</code></pre><p>三个字段表示的意义为：</p>
<ul>
<li>$ref：集合名称</li>
<li>$id：引用的id</li>
<li>$db：数据库名称，可选参数</li>
</ul>
<p>考虑这样的一个场景，我们在不同的集合中 (address_home, address_office, address_mailing, 等)存储不同的地址（住址，办公室地址，邮件地址等）。</p>
<p>这样，我们在调用不同地址时，也需要指定集合，一个文档从多个集合引用文档，我们应该使用 DBRefs。</p>
<p>以下实例中用户数据文档使用了 DBRef, 字段 address：</p>
<pre><code>{
   &quot;_id&quot;:ObjectId(&quot;53402597d852426020000002&quot;),
   &quot;address&quot;: {
   &quot;$ref&quot;: &quot;address_home&quot;,
   &quot;$id&quot;: ObjectId(&quot;534009e4d852427820000002&quot;),
   &quot;$db&quot;: &quot;w3cschoolcc&quot;},
   &quot;contact&quot;: &quot;987654321&quot;,
   &quot;dob&quot;: &quot;01-01-1991&quot;,
   &quot;name&quot;: &quot;Tom Benzamin&quot;
}
</code></pre><p>address DBRef 字段指定了引用的地址文档是在 address_home 集合下的 w3cschoolcc 数据库，id 为 534009e4d852427820000002。</p>
<p>以下代码中，我们通过指定 $ref 参数（address_home 集合）来查找集合中指定id的用户地址信息：</p>
<pre><code>&gt;var user = db.users.findOne({&quot;name&quot;:&quot;Tom Benzamin&quot;})
&gt;var dbRef = user.address
&gt;db[dbRef.$ref].findOne({&quot;_id&quot;:(dbRef.$id)})
</code></pre><h2 id="mongodb-objectid">MongoDB ObjectId</h2>
<p>ObjectId 是一个12字节 BSON 类型数据，有以下格式：</p>
<ul>
<li>前4个字节表示时间戳</li>
<li>接下来的3个字节是机器标识码</li>
<li>紧接的两个字节由进程id组成（PID）</li>
<li>最后三个字节是随机数。</li>
</ul>
<h3 id="-">创建文档的时间戳</h3>
<p>由于 ObjectId 中存储了 4 个字节的时间戳，所以你不需要为你的文档保存时间戳字段，你可以通过 <code>getTimestamp</code> 函数来获取文档的创建时间:</p>
<pre><code>&gt;ObjectId(&quot;5349b4ddd2781d08c09890f4&quot;).getTimestamp()
</code></pre><p>以上代码将返回 ISO 格式的文档创建时间：</p>
<pre><code>ISODate(&quot;2014-04-12T21:49:17Z&quot;)
</code></pre><h3 id="objectid-">ObjectId 转换为字符串</h3>
<p>在某些情况下，您可能需要将ObjectId转换为字符串格式。你可以使用下面的代码：</p>
<pre><code>&gt;new ObjectId().str
</code></pre><p>以上代码将返回Guid格式的字符串：：</p>
<pre><code>5349b4ddd2781d08c09890f3
</code></pre><h2 id="mongodb-gridfs">MongoDB GridFS</h2>
<p>GridFS 用于存储和恢复那些超过16M（BSON文件限制）的文件(如：图片、音频、视频等)。</p>
<p>GridFS 也是文件存储的一种方式，但是它是存储在MonoDB的集合中。
GridFS 可以更好的存储大于16M的文件。</p>
<p>GridFS 会将大文件对象分割成多个小的chunk(文件片段),一般为256k/个,每个chunk将作为MongoDB的一个文档(document)被存储在chunks集合中。</p>
<p>GridFS 用两个集合来存储一个文件：fs.files与fs.chunks。</p>
<p>每个文件的实际内容被存在chunks(二进制数据)中,和文件有关的meta数据(filename,content_type,还有用户自定义的属性)将会被存在files集合中。</p>
<h2 id="mongodb-capped-collections-">MongoDB 固定集合（Capped Collections）</h2>
<p>MongoDB 固定集合（Capped Collections）是性能出色且有着固定大小的集合，对于大小固定，我们可以想象其就像一个环形队列，当集合空间用完后，再插入的元素就会覆盖最初始的头部的元素！</p>
<p>指定文档个数,加上max:1000属性：</p>
<pre><code>&gt;db.createCollection(&quot;cappedLogCollection&quot;,{capped:true,size:10000,max:1000})
</code></pre><p><strong>固定集合属性及用法</strong></p>
<p>属性</p>
<ol>
<li>属性1:对固定集合进行插入速度极快</li>
<li>属性2:按照插入顺序的查询输出速度极快</li>
<li>属性3:能够在插入最新数据时,淘汰最早的数据</li>
</ol>
<p>用法</p>
<ol>
<li>用法1:储存日志信息</li>
<li>用法2:缓存一些少量的文档</li>
</ol>
<h2 id="mongodb-">MongoDB 自动增长</h2>
<p>MongoDB 没有像 SQL 一样有自动增长的功能， MongoDB 的 _id 是系统自动生成的12字节唯一标识。</p>
<p>但在某些情况下，我们可能需要实现 ObjectId 自动增长功能。</p>
<p>由于 MongoDB 没有实现这个功能，我们可以通过编程的方式来实现，以下我们将在 counters 集合中实现_id字段自动增长。</p>
<h3 id="-counters-">使用 counters 集合</h3>
<p>考虑以下 products 文档。我们希望 _id 字段实现 从 1,2,3,4 到 n 的自动增长功能。</p>
<pre><code>{
  &quot;_id&quot;:1,
  &quot;product_name&quot;: &quot;Apple iPhone&quot;,
  &quot;category&quot;: &quot;mobiles&quot;
}
</code></pre><p>为此，创建 counters 集合，序列字段值可以实现自动长：</p>
<pre><code>&gt;db.createCollection(&quot;counters&quot;)
</code></pre><p>现在我们向 counters 集合中插入以下文档，使用 productid 作为 key:</p>
<pre><code>{
  &quot;_id&quot;:&quot;productid&quot;,
  &quot;sequence_value&quot;: 0
}
</code></pre><p>sequence_value 字段是序列通过自动增长后的一个值。
使用以下命令插入 counters 集合的序列文档中：</p>
<pre><code>&gt;db.counters.insert({_id:&quot;productid&quot;,sequence_value:0})
</code></pre><h3 id="-javascript-">创建 Javascript 函数</h3>
<p>现在，我们创建函数 getNextSequenceValue 来作为序列名的输入， 指定的序列会自动增长 1 并返回最新序列值。在本文的实例中序列名为 productid 。</p>
<pre><code>&gt;function getNextSequenceValue(sequenceName){
   var sequenceDocument = db.counters.findAndModify(
      {
         query:{_id: sequenceName },
         update: {$inc:{sequence_value:1}},
         new:true
      });
   return sequenceDocument.sequence_value;
}
</code></pre><p>使用 Javascript 函数
接下来我们将使用 getNextSequenceValue 函数创建一个新的文档， 并设置文档 _id 自动为返回的序列值：</p>
<pre><code>&gt;db.products.insert({
   &quot;_id&quot;:getNextSequenceValue(&quot;productid&quot;),
   &quot;product_name&quot;:&quot;Apple iPhone&quot;,
   &quot;category&quot;:&quot;mobiles&quot;})
</code></pre><pre><code>&gt;db.products.insert({
   &quot;_id&quot;:getNextSequenceValue(&quot;productid&quot;),
   &quot;product_name&quot;:&quot;Samsung S3&quot;,
   &quot;category&quot;:&quot;mobiles&quot;})
</code></pre><p>就如你所看到的，我们使用 getNextSequenceValue 函数来设置 _id 字段。</p>
<p>为了验证函数是否有效，我们可以使用以下命令读取文档：</p>
<pre><code>&gt;db.products.find()
</code></pre><p>以上命令将返回以下结果，我们发现 _id 字段是自增长的：</p>
<pre><code>{ &quot;_id&quot; : 1, &quot;product_name&quot; : &quot;Apple iPhone&quot;, &quot;category&quot; : &quot;mobiles&quot;}

{ &quot;_id&quot; : 2, &quot;product_name&quot; : &quot;Samsung S3&quot;, &quot;category&quot; : &quot;mobiles&quot; }
</code></pre>